<!DOCTYPE html>
<meta charset="utf-8" />
<style>
  .tvhc {
    color: var(--content-color, #eee);
    display: flex;
    flex-direction: column;
    height: 100%;
  }

  .row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin: 6px 0;
  }


  .ctrl {
    display: grid;
    grid-auto-flow: column;
    grid-auto-columns: max-content;
    align-items: center;
    column-gap: 24px;
    background: color-mix(in srgb, var(--content-color, #eee) 10%, transparent);    padding: 4px;
    border-radius: 50px;
  }

  /* Each group has 4 columns: label | minus | value | plus */
  .grp {
    display: grid;
    grid-template-columns: max-content 28px 40px 28px;
    align-items: center;
    column-gap: 8px;
  }

  .grp>.label {
    width: 36px;
    text-align: right;
    opacity: .8;
  }

  .val {
    width: 40px;
    text-align: center;
    font-weight: 600;
  }

  /* Responsive: stack buttons vertically when width is limited */
  @media (max-width: 420px) {
    /* Stack groups under each other */
    .ctrl { grid-auto-flow: row; row-gap: 12px; }

    /* Within each group, place +/- under each other next to the value */
    .grp {
      grid-template-columns: 28px 1fr;
      grid-template-rows: auto auto auto;
      grid-template-areas:
        "label label"
        "minus value"
        "plus value";
      column-gap: 8px;
      row-gap: 6px;
    }
    .grp > .label { grid-area: label; width: auto; text-align: left; }
    .grp > button:first-of-type { grid-area: minus; }
    .grp > .val { grid-area: value; justify-self: start; }
    .grp > button:last-of-type { grid-area: plus; }
  }

  button {
    width: 28px;
    height: 28px;
    color: var(--accent-color, #eee);
    cursor: pointer;
    background: var(--card-color, #eee);
    border: none;
    appearance: none;
    -webkit-appearance: none;
    padding: 0;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
    border-radius: 50px;
  }

  .controls-area {
    flex: 0 0 auto;
  }

  .mini {
    flex: 1 1 auto;
    margin-top: 8px;
    min-height: 200px;
    overflow: hidden;
  }

  canvas {
    width: 100%;
    height: 100%;
    display: block;
    background: transparent;
  }
</style>
<div class="tvhc">
  <div class="mini">
    <canvas id="chart"></canvas>
  </div>
  <div class="controls-area">
    <div class="row">
      <div class="label" data-i18n="Flow Temperature">Flow Temperature</div>
      <div class="ctrl">
        <div class="grp">
          <div class="label" data-i18n="Min">Min</div>
          <button data-ident="MinVL" data-delta="-1">−</button>
          <div class="val" id="val-MinVL">--</div>
          <button data-ident="MinVL" data-delta="+1">+</button>
        </div>
        <div class="grp">
          <div class="label" data-i18n="Max">Max</div>
          <button data-ident="MaxVL" data-delta="-1">−</button>
          <div class="val" id="val-MaxVL">--</div>
          <button data-ident="MaxVL" data-delta="+1">+</button>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="label" data-i18n="Plateau">Plateau</div>
      <div class="ctrl">
        <div class="grp">
          <div class="label" data-i18n="Start">Start</div>
          <button data-ident="StartAT" data-delta="-1">−</button>
          <div class="val" id="val-StartAT">--</div>
          <button data-ident="StartAT" data-delta="+1">+</button>
        </div>
        <div class="grp">
          <div class="label" data-i18n="End">End</div>
          <button data-ident="EndAT" data-delta="-1">−</button>
          <div class="val" id="val-EndAT">--</div>
          <button data-ident="EndAT" data-delta="+1">+</button>
        </div>
      </div>
    </div>
  </div>
</div>
<script>
(function(){
  const $ = (id)=>document.getElementById(id);

  function fmt(v, unit){
    if (v === null || v === undefined) return '--';
    return Math.round(v).toFixed(0) + unit;
  }

  function drawChart(p){
    const canvas = document.getElementById('chart');
    if (!canvas) return;
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const cssW = Math.max(160, rect.width || 160);
    const cssH = Math.max(80, rect.height || 80);
    const needResize = canvas.width !== Math.round(cssW * dpr) || canvas.height !== Math.round(cssH * dpr);
    if (needResize) {
      canvas.width = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);
    }
    const ctx = canvas.getContext('2d');
    // Reset transform, clear full pixel buffer, then scale to CSS pixels
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Colors from CSS variables (read from nearest container for reliability)
    const container = canvas.closest('.tvhc') || document.documentElement;
    const css = getComputedStyle(container);
    const systemFontSize = parseFloat(css.fontSize) || 14;
    let accentColor = (css.getPropertyValue('--accent-color') || '').trim() || '#6cf';
    let contentColor = (css.getPropertyValue('--content-color') || '').trim() || '#eee';
    let curveColor = (css.getPropertyValue('--curve-color') || '').trim() || '#fc6';
    let pointColor = (css.getPropertyValue('--point-color') || '').trim() || '#2c7dd3';
    let markerColor = (css.getPropertyValue('--marker-color') || '').trim() || '#ffd54f';
    let curveLeftColor = (css.getPropertyValue('--curve-left-color') || '').trim() || '#ffb300'; // orange
    let curveRightColor = (css.getPropertyValue('--curve-right-color') || '').trim() || '#e53935'; // red
    // Ensure visible distinction if curve and accent are identical or too similar
    const parseRGB = (c)=>{
      if (!c) return null;
      const s = c.toLowerCase().trim();
      if (s.startsWith('#')){
        const h = s.replace('#','');
        if (h.length === 3){
          const r = parseInt(h[0]+h[0],16), g = parseInt(h[1]+h[1],16), b = parseInt(h[2]+h[2],16);
          return {r,g,b};
        } else if (h.length === 6){
          const r = parseInt(h.slice(0,2),16), g = parseInt(h.slice(2,4),16), b = parseInt(h.slice(4,6),16);
          return {r,g,b};
        }
        return null;
      } else if (s.startsWith('rgb')){
        const m = s.match(/rgba?\(([^)]+)\)/);
        if (!m) return null;
        const parts = m[1].split(',').map(t=>parseFloat(t.trim()));
        if (parts.length >= 3) return {r:parts[0], g:parts[1], b:parts[2]};
        return null;
      }
      return null;
    };
    const ac = parseRGB(accentColor), cc = parseRGB(curveColor);
    if (ac && cc){
      const dd = Math.abs(ac.r-cc.r) + Math.abs(ac.g-cc.g) + Math.abs(ac.b-cc.b);
      if (dd < 30){ // too similar
        curveColor = '#ffb300';
      }
    } else if (curveColor && accentColor && curveColor.toLowerCase() === accentColor.toLowerCase()) {
      curveColor = '#ffb300';
    }
    // Ensure point color is distinct from curve and accent
    const pc = parseRGB(pointColor), cc2 = parseRGB(curveColor), ac2 = parseRGB(accentColor);
    const tooClose = (a,b)=> a && b && (Math.abs(a.r-b.r)+Math.abs(a.g-b.g)+Math.abs(a.b-b.b) < 30);
    if (tooClose(pc, cc2) || tooClose(pc, ac2)) {
      pointColor = '#1e88e5';
    }
    // Ensure marker color is distinct from curve and accent
    const mc = parseRGB(markerColor);
    if (tooClose(mc, cc2) || tooClose(mc, ac2)) {
      markerColor = '#ffcc80';
    }

    // Chart area with gutters for labels (labels outside the plotted area)
    const padL = 50, padR = 10, padT = 30, padB = 30;
    const W = cssW - padL - padR;
    const H = cssH - padT - padB;
    if (W <= 0 || H <= 0) return;

    const atMin = p.MinAT, atMax = p.MaxAT;            // dynamic X axis (Außentemperatur)
    const vlMinProp = p.MinVorlauf, vlMaxProp = p.MaxVorlauf; // properties for curve endpoints
    let startAT = (typeof p.StartAT === 'number') ? p.StartAT : atMax;
    let endAT = (typeof p.EndAT === 'number') ? p.EndAT : atMin;
    // Y axis (Vorlauf) from backend configuration with fallback values
    const vlAxisMin = (typeof p.VLScaleMin === 'number' && isFinite(p.VLScaleMin)) ? p.VLScaleMin : 20;
    const vlAxisMax = (typeof p.VLScaleMax === 'number' && isFinite(p.VLScaleMax)) ? p.VLScaleMax : 50;
    const atSpan = atMax - atMin;
    const vlAxisSpan = vlAxisMax - vlAxisMin;

    // Clamp helper and clamped Vorlauf endpoints for drawing (with safe fallback)
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const toNum = (v, fb) => (typeof v === 'number' && isFinite(v) ? v : fb);
    const vlMin = clamp(toNum(vlMinProp, vlAxisMin), vlAxisMin, vlAxisMax);
    const vlMax = clamp(toNum(vlMaxProp, vlAxisMax), vlAxisMin, vlAxisMax);

    const mapX = (at) => {
      if (!isFinite(atSpan) || atSpan === 0) return padL;
      const t = (at - atMin) / atSpan; // 0 at MinAT, 1 at MaxAT
      return padL + (1 - t) * W;      // invert so warm (MaxAT) is left
    };
    const mapY = (vl) => {
      if (!isFinite(vlAxisSpan) || vlAxisSpan === 0) return padT + H;
      const t = (vl - vlAxisMin) / vlAxisSpan; // 0 at axis min (bottom), 1 at axis max (top)
      return padT + (1 - t) * H;
    };

    // Axes
    ctx.strokeStyle = accentColor;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padL, padT);
    ctx.lineTo(padL, padT + H);
    ctx.lineTo(padL + W, padT + H);
    ctx.stroke();

    // Tick helper
    function niceStep(range, targetTicks){
      if (!isFinite(range) || range <= 0) return 1;
      const raw = range / targetTicks;
      const pow = Math.pow(10, Math.floor(Math.log10(raw)));
      const base = raw / pow;
      let nice;
      if (base < 1.5) nice = 1;
      else if (base < 3) nice = 2;
      else if (base < 7) nice = 5;
      else nice = 10;
      return nice * pow;
    }
    function drawYTicks(){
      const step = niceStep(vlAxisSpan, 4);
      const start = Math.ceil(vlAxisMin / step) * step;
      ctx.fillStyle = contentColor;
      ctx.font = systemFontSize + 'px sans-serif';
      ctx.textAlign = 'right';
      const labelGap = 10;
      const yMin = padT + H;
      const yMax = padT;
      for (let v = start; v <= vlAxisMax + 1e-6; v += step){
        const y = mapY(v);
        ctx.strokeStyle = accentColor;
        ctx.beginPath();
        // draw tick outward (to the left) into the label gutter
        ctx.moveTo(padL - 3, y);
        ctx.lineTo(padL, y);
        ctx.stroke();
        // Align bottom label up and top label down to prevent clipping
        if (y >= yMin - 5) {
          ctx.textBaseline = 'bottom';
        } else if (y <= yMax + 5) {
          ctx.textBaseline = 'top';
        } else {
          ctx.textBaseline = 'middle';
        }
        // place label in the left gutter
        ctx.fillText(v.toFixed(0) + '°C', padL - labelGap, y);
      }
    }
    function drawXTicks(){
      const step = niceStep(atSpan, 4);
      const start = Math.ceil(atMin / step) * step;
      ctx.fillStyle = contentColor;
      ctx.font = systemFontSize + 'px sans-serif';
      // place labels below the bottom axis into the bottom gutter
      ctx.textBaseline = 'top';
      const labelGap = 10;
      const xMax = padL + W;
      const xMin = padL;
      for (let a = start; a <= atMax + 1e-6; a += step){
        const x = mapX(a);
        ctx.strokeStyle = accentColor;
        ctx.beginPath();
        // draw tick outward (downwards) into the bottom gutter
        ctx.moveTo(x, padT + H);
        ctx.lineTo(x, padT + H + 3);
        ctx.stroke();
        // Align leftmost label to the left and rightmost label to the right to prevent clipping
        if (x <= xMin + 5) {
          ctx.textAlign = 'left';
        } else if (x >= xMax - 5) {
          ctx.textAlign = 'right';
        } else {
          ctx.textAlign = 'center';
        }
        ctx.fillText(a.toFixed(0) + '°C', x, padT + H + labelGap);
      }
    }
    drawYTicks();
    drawXTicks();

    // Current AT marker on X-axis
    if (typeof p.AT === 'number' && isFinite(p.AT)){
      const atX = Math.max(padL, Math.min(padL + W, mapX(p.AT)));
      const atY = padT + H;
      // Draw marker point
      ctx.fillStyle = '#3b82f6';
      ctx.beginPath();
      ctx.arc(atX, atY, 3, 0, Math.PI*2);
      ctx.fill();
      // Draw temperature label above the point
      const text = Math.round(p.AT) + '°C';
      ctx.font = 'bold ' + systemFontSize + 'px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      const metrics = ctx.measureText(text);
      const bgPadding = 4;
      const bgRadius = 4;
      const labelY = atY - 8;
      // Draw rounded rectangle background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      const rectX = atX - metrics.width / 2 - bgPadding;
      const rectY = labelY - systemFontSize - bgPadding;
      const rectW = metrics.width + bgPadding * 2;
      const rectH = systemFontSize + bgPadding * 2;
      ctx.beginPath();
      ctx.moveTo(rectX + bgRadius, rectY);
      ctx.lineTo(rectX + rectW - bgRadius, rectY);
      ctx.arcTo(rectX + rectW, rectY, rectX + rectW, rectY + bgRadius, bgRadius);
      ctx.lineTo(rectX + rectW, rectY + rectH - bgRadius);
      ctx.arcTo(rectX + rectW, rectY + rectH, rectX + rectW - bgRadius, rectY + rectH, bgRadius);
      ctx.lineTo(rectX + bgRadius, rectY + rectH);
      ctx.arcTo(rectX, rectY + rectH, rectX, rectY + rectH - bgRadius, bgRadius);
      ctx.lineTo(rectX, rectY + bgRadius);
      ctx.arcTo(rectX, rectY, rectX + bgRadius, rectY, bgRadius);
      ctx.closePath();
      ctx.fill();
      // Draw text
      ctx.fillStyle = '#3b82f6';
      ctx.fillText(text, atX, labelY);
    }

    // Heating curve: left plateau (MaxAT..StartAT) ->slope (StartAT..EndAT) -> right plateau (EndAT..MinAT)
    // Clamp plateau bounds into range and ensure order: endAT <= startAT
    startAT = Math.max(atMin, Math.min(atMax, startAT));
    endAT = Math.max(atMin, Math.min(atMax, endAT));
    if (endAT > startAT) { const t = endAT; endAT = startAT; startAT = t; }

    // Heating curve: left plateau (MaxAT..StartAT) -> slope (StartAT..EndAT) -> right plateau (EndAT..MinAT)
    const xLeft = mapX(atMax);     // warm extreme
    const xStart = mapX(startAT);
    const xEnd = mapX(endAT);
    const xRight = mapX(atMin);    // cold extreme
    const yWarm = mapY(vlMin); // VL at warm side (clamped)
    const yCold = mapY(vlMax); // VL at cold side (clamped)

    // Gradient from left (orange) to right (red)
    const grad = ctx.createLinearGradient(xLeft, 0, xRight, 0);
    grad.addColorStop(0, curveLeftColor);
    grad.addColorStop(1, curveRightColor);
    ctx.strokeStyle = grad;
    ctx.setLineDash([]);
    ctx.globalAlpha = 1;
    ctx.lineWidth = 3;
    ctx.lineJoin = 'round';
    ctx.beginPath();
    // left plateau
    ctx.moveTo(xLeft, yWarm);
    ctx.lineTo(xStart, yWarm);
    // rising/falling segment
    ctx.lineTo(xEnd, yCold);
    // right plateau
    ctx.lineTo(xRight, yCold);
    ctx.stroke();

    // Control points (schematic style)
    function dot(x, y){
      ctx.fillStyle = accentColor;
      ctx.beginPath();
      ctx.arc(x, y, 3.5, 0, Math.PI*2);
      ctx.fill();
    }
    dot(xLeft, yWarm);
    dot(xStart, yWarm);
    dot(xEnd, yCold);
    dot(xRight, yCold);

    // Current AT marker (snap to drawn curve)
    if (typeof p.AT === 'number' && isFinite(p.AT)){
      const cx = Math.max(padL, Math.min(padL + W, mapX(p.AT)));
      // piecewise: warm plateau -> slope -> cold plateau
      let vlAtAT;
      if (p.AT >= startAT) {
        vlAtAT = vlMin;
      } else if (p.AT <= endAT) {
        vlAtAT = vlMax;
      } else {
        const t = (p.AT - endAT) / (startAT - endAT); // 0 at endAT (cold), 1 at startAT (warm)
        vlAtAT = vlMax + t * (vlMin - vlMax);
      }
      const vlAtATClamped = clamp(vlAtAT, vlAxisMin, vlAxisMax);
      const cy = Math.max(padT, Math.min(padT + H, mapY(vlAtATClamped)));
      ctx.setLineDash([4,3]);
      ctx.strokeStyle = 'rgba(252, 198, 102, 1)';
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx, padT + H);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = '#fc6';
      ctx.beginPath();
      ctx.arc(cx, cy, 6, 0, Math.PI*2);
      ctx.fill();
      
      // Display VL temperature next to the marker
      if (typeof p.VL === 'number' && isFinite(p.VL)) {
        ctx.fillStyle = contentColor;
        ctx.font = 'bold ' + systemFontSize + 'px sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        const textX = cx + 8;
        const textY = cy;
        // Draw text background for better readability
        const text = Math.round(p.VL) + '°C';
        const metrics = ctx.measureText(text);
        const bgPadding = 4;
        const bgRadius = 4;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        const rectX = textX - bgPadding;
        const rectY = textY - 8;
        const rectW = metrics.width + bgPadding * 2;
        const rectH = 16;
        // Draw rounded rectangle
        ctx.beginPath();
        ctx.moveTo(rectX + bgRadius, rectY);
        ctx.lineTo(rectX + rectW - bgRadius, rectY);
        ctx.arcTo(rectX + rectW, rectY, rectX + rectW, rectY + bgRadius, bgRadius);
        ctx.lineTo(rectX + rectW, rectY + rectH - bgRadius);
        ctx.arcTo(rectX + rectW, rectY + rectH, rectX + rectW - bgRadius, rectY + rectH, bgRadius);
        ctx.lineTo(rectX + bgRadius, rectY + rectH);
        ctx.arcTo(rectX, rectY + rectH, rectX, rectY + rectH - bgRadius, bgRadius);
        ctx.lineTo(rectX, rectY + bgRadius);
        ctx.arcTo(rectX, rectY, rectX + bgRadius, rectY, bgRadius);
        ctx.closePath();
        ctx.fill();
        // Draw text
        ctx.fillStyle = '#fc6';
        ctx.fillText(text, textX, textY);
      }
    }
  }

  // Store current payload for button validation
  let currentPayload = null;
  let gotInit = false;

  function setVals(p){
    currentPayload = p; // Store for button validation
    const clamp = (v, min, max) => (typeof v === 'number' ? Math.max(min, Math.min(max, v)) : v);
    // Validation range from backend configuration with fallback values
    const VL_MIN = (typeof p.VLScaleMin === 'number' && isFinite(p.VLScaleMin)) ? p.VLScaleMin : 0;
    const VL_MAX = (typeof p.VLScaleMax === 'number' && isFinite(p.VLScaleMax)) ? p.VLScaleMax : 50;

    const minVLDisp = clamp(p.MinVorlauf, VL_MIN, VL_MAX);
    const maxVLDisp = clamp(p.MaxVorlauf, VL_MIN, VL_MAX);

    $('val-MinVL').textContent = fmt(minVLDisp, ' °C');
    $('val-MaxVL').textContent = fmt(maxVLDisp, ' °C');
    if (document.getElementById('val-StartAT')) {
      const sAT = (typeof p.StartAT === 'number') ? p.StartAT : p.MaxAT;
      $('val-StartAT').textContent = fmt(clamp(sAT, p.MinAT, p.MaxAT), ' °C');
    }
    if (document.getElementById('val-EndAT')) {
      const eAT = (typeof p.EndAT === 'number') ? p.EndAT : p.MinAT;
      $('val-EndAT').textContent = fmt(clamp(eAT, p.MinAT, p.MaxAT), ' °C');
    }
    drawChart(p);
    updateButtonStates(p);
  }

  function updateButtonStates(p){
    if (!p) return;
    const VL_MIN = (typeof p.VLScaleMin === 'number' && isFinite(p.VLScaleMin)) ? p.VLScaleMin : 0;
    const VL_MAX = (typeof p.VLScaleMax === 'number' && isFinite(p.VLScaleMax)) ? p.VLScaleMax : 50;
    const AT_MIN = (typeof p.MinAT === 'number' && isFinite(p.MinAT)) ? p.MinAT : -60;
    const AT_MAX = (typeof p.MaxAT === 'number' && isFinite(p.MaxAT)) ? p.MaxAT : 60;

    document.querySelectorAll('button[data-ident]').forEach(btn=>{
      const ident = btn.getAttribute('data-ident');
      const delta = parseFloat(btn.getAttribute('data-delta'));
      let disabled = false;

      if (ident === 'MinVL') {
        const newVal = (p.MinVorlauf || 0) + delta;
        disabled = newVal < VL_MIN || newVal > VL_MAX;
      } else if (ident === 'MaxVL') {
        const newVal = (p.MaxVorlauf || 0) + delta;
        disabled = newVal < VL_MIN || newVal > VL_MAX;
      } else if (ident === 'StartAT') {
        const newVal = ((typeof p.StartAT === 'number') ? p.StartAT : AT_MAX) + delta;
        disabled = newVal < AT_MIN || newVal > AT_MAX;
      } else if (ident === 'EndAT') {
        const newVal = ((typeof p.EndAT === 'number') ? p.EndAT : AT_MIN) + delta;
        disabled = newVal < AT_MIN || newVal > AT_MAX;
      }

      btn.disabled = disabled;
      btn.style.opacity = disabled ? '0.3' : '1';
      btn.style.cursor = disabled ? 'not-allowed' : 'pointer';
    });
  }

  // Button wiring
  document.querySelectorAll('button[data-ident]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      if (btn.disabled) return; // Extra safety check
      const ident = btn.getAttribute('data-ident');
      const delta = parseFloat(btn.getAttribute('data-delta'));
      if (typeof requestAction === 'function' && currentPayload) {
        // Validate before sending
        const p = currentPayload;
        const VL_MIN = (typeof p.VLScaleMin === 'number' && isFinite(p.VLScaleMin)) ? p.VLScaleMin : 0;
        const VL_MAX = (typeof p.VLScaleMax === 'number' && isFinite(p.VLScaleMax)) ? p.VLScaleMax : 50;
        
        let valid = true;
        if (ident === 'MinVL' || ident === 'MaxVL') {
          const currentVal = ident === 'MinVL' ? (p.MinVorlauf || 0) : (p.MaxVorlauf || 0);
          const newVal = currentVal + delta;
          if (newVal < VL_MIN || newVal > VL_MAX) valid = false;
        }
        
        if (valid) {
          requestAction(ident, delta);
        }
      }
    });
  });

  // HTML-SDK entry point for live updates
  window.handleMessage = function(payload){
    try {
      const p = (typeof payload === 'string') ? JSON.parse(payload) : payload;
      setVals(p);
      gotInit = true;
    } catch (e) {
      console.error('handleMessage parse error', e);
    }
  };

  // Symcon HTML-SDK compatibility: backend may call this function directly
  window.UpdateVisualizationValue = function(payload){
    window.handleMessage(payload);
  };

  // Listen for messages from backend (UpdateVisualizationValue -> postMessage)
  window.addEventListener('message', (ev)=>{
    try {
      const d = ev.data;
      if (d === undefined || d === null) return;
      // Heuristics: accept both JSON string and object
      const p = (typeof d === 'string') ? JSON.parse(d) : d;
      if (p && (typeof p === 'object')) {
        window.handleMessage(p);
      }
    } catch(e) {
      // ignore malformed messages
    }
  });

  // Request initial payload from backend after template loads
  function initHandshake(){
    let attempts = 0;
    const maxAttempts = 50; // ~10s @ 200ms
    const tryInit = ()=>{
      if (typeof requestAction === 'function') {
        try { requestAction('Init', 0); } catch(e) {}
      }
      if (!gotInit && attempts < maxAttempts) {
        attempts++;
        setTimeout(tryInit, 200);
      }
    };
    tryInit();
  }
  initHandshake();
})();
</script>
